#! /usr/bin/env python

# Copyright (C) 2015 Ross Burton <ross.burton@intel.com>
# MIT licensed

import email, subprocess

class PatchSource:

      def enumerate(self):
            pass

      def apply(self):
            pass

class ClipboardPatch(PatchSource):
      def __init__(self):
            # TODO: respect platform
            self.patch = subprocess.check_output(['xsel', '-b'])

            # Check the clipboard contains something that looks like a patch
            process = subprocess.Popen(['git', 'apply', '--check', '-'],
                                       stdin=subprocess.PIPE)
            process.communicate(self.patch)
            retcode = process.poll()
            if retcode:
                  raise subprocess.CalledProcessError(retcode, 'git-apply')

      def enumerate(self):
            return (email.message_from_string(self.patch)['Subject'],)

      def apply(self):
            gitam = subprocess.Popen(['git', 'am', '--3way', '--signoff', '--whitespace=nowarn'],
                                  stdin=subprocess.PIPE)
            gitam.communicate(self.patch)
            retcode = gitam.poll()
            if retcode:
                  raise subprocess.CalledProcessError(retcode, 'git')


class FilePatch(PatchSource):
      def __init__(self, files):
            self.files = files

      def enumerate(self):
            return (email.message_from_file(open(f))['Subject'] for f in self.files)

      def apply(self):
            subprocess.check_call(['git', 'am', '--3way', '--signoff', '--whitespace=nowarn'] + self.files)


class RevisionsPatch(PatchSource):
      def __init__(self, revisions):
            self.revs = revisions

      def enumerate(self):
            return subprocess.check_output(['git', 'show', '--no-patch', '--format=format:%s'] + self.revs).split('\n')

      def apply(self):
            subprocess.check_call(['git', 'cherry-pick', '--signoff'] + self.revs)


def wipe_sysroot():
      subprocess.check_call(['wipe-sysroot'])

def build(targets):
      subprocess.check_call(['bitbake'] + targets)

def buildhistory():
      subprocess.check_call(['buildhistory-diff'])


if __name__ == "__main__":
      import argparse

      args = argparse.ArgumentParser(description="Applyotron")
      group = args.add_mutually_exclusive_group(required=True)
      group.add_argument("-c", "--clipboard", action="store_true", help="Take patch from clipboard")
      group.add_argument("-f", "--file", action="append", help="Take patch from file")
      group.add_argument("-r", "--revisions", action="append", help="Cherry-pick revision range")
      args.add_argument('target', nargs='+', help='targets to build')
      args = args.parse_args()

      if args.clipboard:
            patch = ClipboardPatch()
      elif args.file:
            patch = FilePatch(args.file)
      elif args.revisions:
            patch = RevisionsPatch(args.revisions)
      else:
            raise ValueError("No patch source selected")

      print "Applying the following patches:"
      print "\n ".join(patch.enumerate())

      targets = args.target
      # TODO exception handling
      # TODO If I control-C applyotron the childs keep on running. This is bad.
      build(targets)
      patch.apply()
      wipe_sysroot()
      build(targets)
      buildhistory()
