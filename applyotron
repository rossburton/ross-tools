#! /usr/bin/env python

# Copyright (C) 2015 Ross Burton <ross.burton@intel.com>
# MIT licensed

import email, subprocess

class PatchSource:
      def enumerate(self):
            """
            Return a summary of the patches to be applied as a list of strings.
            """
            pass

      def apply(self):
            """
            Apply the patches, raising an exception if there is an error.
            """
            pass

class ClipboardPatch(PatchSource):
      def __init__(self):
            import tempfile

            # Save the clipboard contents for passing to git-am in apply()
            # TODO: respect platform, eg pbcopy for osx
            self.mail = subprocess.check_output(['xsel', '-b'])

            # Check the clipboard contains something that looks like a patch.
            # As the clipboard contains an email it could be encoded, so use
            # git-mailinfo to extract the patch itself first.  It's a shame
            # git-am doesn't have a --dry-run option.
            with tempfile.NamedTemporaryFile(prefix="applyotron") as patchfile:
                  process = subprocess.Popen(['git', 'mailinfo', '/dev/null', patchfile.name],
                                             stdin=subprocess.PIPE, stdout=subprocess.PIPE)
                  process.communicate(self.mail)
                  retcode = process.wait()
                  if retcode:
                        raise subprocess.CalledProcessError(retcode, 'git-mailinfo')

                  process = subprocess.check_call(['git', 'apply', '--check', patchfile.name])

      def enumerate(self):
            return (email.message_from_string(self.mail)['Subject'],)

      def apply(self):
            gitam = subprocess.Popen(['git', 'am', '--3way', '--signoff', '--whitespace=nowarn'],
                                  stdin=subprocess.PIPE)
            gitam.communicate(self.mail)
            retcode = gitam.poll()
            if retcode:
                  raise subprocess.CalledProcessError(retcode, 'git')


class FilePatch(PatchSource):
      def __init__(self, files):
            self.files = files

      def enumerate(self):
            return (email.message_from_file(open(f))['Subject'] for f in self.files)

      def apply(self):
            subprocess.check_call(['git', 'am', '--3way', '--signoff', '--whitespace=nowarn'] + self.files)


class RevisionsPatch(PatchSource):
      def __init__(self, revisions):
            self.revs = revisions

      def enumerate(self):
            return subprocess.check_output(['git', 'show', '--no-patch', '--format=format:%s'] + self.revs).split('\n')

      def apply(self):
            subprocess.check_call(['git', 'cherry-pick', '--signoff'] + self.revs)


def wipe_sysroot():
      subprocess.check_call(['wipe-sysroot'])

def build(targets):
      subprocess.check_call(['bitbake'] + targets)

def buildhistory():
      subprocess.check_call(['buildhistory-diff'])


if __name__ == "__main__":
      import argparse

      args = argparse.ArgumentParser(description="Applyotron")
      group = args.add_mutually_exclusive_group(required=True)
      group.add_argument("-c", "--clipboard", action="store_true", help="Take patch from clipboard")
      group.add_argument("-f", "--file", action="append", help="Take patch from file")
      group.add_argument("-r", "--revisions", action="append", help="Cherry-pick revision range")
      args.add_argument('target', nargs='+', help='targets to build')
      args = args.parse_args()

      if args.clipboard:
            patch = ClipboardPatch()
      elif args.file:
            patch = FilePatch(args.file)
      elif args.revisions:
            patch = RevisionsPatch(args.revisions)
      else:
            raise ValueError("No patch source selected")

      print "Applying the following patches:"
      print "\n ".join(patch.enumerate())

      targets = args.target
      # TODO exception handling
      # TODO If I control-C applyotron the childs keep on running. This is bad.
      build(targets)
      patch.apply()
      wipe_sysroot()
      build(targets)
      buildhistory()
